---
title: Cho ph√©p c√†i plugin trong java nh∆∞ th·∫ø n√†o?
catalog: true
tags:
  - java
  - plugin
id: 412
categories:
  - Linh tinh
date: 2016-08-07 01:15:03
subtitle:
header-img:
---

Ch·∫£ l√† ƒëang t·∫≠p t·ªçe l√†m wordpress plugin, b·ªóng d∆∞ng n·∫£y ra c√¢u h·ªèi th·∫ø c√†i ƒë·∫∑t plugin trong java nh∆∞ th·∫ø n√†o. Tr∆∞·ªõc gi·ªù c≈©ng ch·ªâ l√†m theo ki·ªÉu y√™u c·∫ßu ƒë·∫øn ƒë√¢u vi·∫øt ƒë·∫øn ƒë·∫•y ch·ª© ch∆∞a ƒë∆∞·ª£c l√†m ki·ªÉu plugin n√†y bao gi·ªù c·∫£. ƒê√†nh h·ªèi b√°c G√∫c v·∫≠y. Sau m·ªôt h·ªìi ƒë√†o b·ªõi c≈©ng g·ªçi l√† n·∫Øm ƒë∆∞·ªçc ƒë√¥i ph·∫ßn, note ra ƒë√¢y cho b√°c n√†o c√πng chung th·∫Øc m·∫Øc.

![plugin](../media/plugin.jpg)

<!--more-->

## Plugin l√† kh·ªâ g√¨?

N√≥i th·∫ø ch·ª© plugin ch·∫Øc kh√¥ng l·∫° g√¨ r·ªìi, ƒëi·ªÉn h√¨nh nh∆∞ c√°c th·ªÉ lo·∫°i tr√¨nh duy·ªát ph·ªï bi·∫øn nh∆∞ Chrome, Firefox, Opera ki·ªÉu g√¨ m·ªói c√°i ch·∫£ c√†i m·ªôt ƒë·ªëng plugin ƒë·∫øn khi tr√¨nh duy·ªát c√≥ g√¨ b·∫•t th∆∞·ªùng l·∫°i ch·∫£ l√¥i ƒë·∫ßu m·∫•y th·∫±ng plugin ra ki·ªÉm ra ƒë·∫ßu ti√™n. M·ªôt c√°ch ƒë∆°n gi·∫£n th√¨ Plugin ch√≠nh l√† m·ªôt b·ªô ph·∫ßn m·ªÅm c√†i ƒë·∫∑t ƒë·ªÉ h·ªó tr·ª£, m·ªü r·ªông ch·ª©c nƒÉng cho m·ªôt ph·∫ßn m·ªÅm ·ª©ng d·ª•ng l·ªõn h∆°n, d·ª±a tr·∫≠n nh∆∞ng giao th·ª©c v√† API do ph·∫ßn m·ªÅm l·ªõn cung c·∫•p.

## Plugin c√≥ g√¨ hay ho?

Ki·∫øn tr√∫c plugin th·ª±c s·ª± r·∫•t tuy·ªát v·ªùi, n√≥ cho ph√©p m·ªü r·ªông (th·∫≠p ch√≠ l√† thay ƒë·ªïi) c√°c ch·ª©c nƒÉng c·ªßa c√°c host applications (t·∫°m g·ªçi l√† ·ª©ng d·ª•ng ch·ªß ƒëi), v·ªõi m·ªôt thi·∫øt k·∫ø t·ªët c√°c ·ª©ng d·ª•ng c√≥ th·ªÉ c·∫Øm th√™m bao nhi√™u ch·ª©c nƒÉng t√πy th√≠ch m·ªói plugin mang ƒë·∫øn m·ªôt ti·ªán √≠ch d·∫´n ƒë·∫øn kh·∫£ nƒÉng m·ªü r·ªông c·ªßa h·ªá th·ªëng l√† c·ª±c k·ª≥ tuy·ªát v·ªùi m√¨nh xin ph√©p ƒë∆∞·ªçc nhai l·∫°i m·ªôt l·∫ßn n·ªØa l√† ph·∫£i thi·∫øt k·∫ø cho t·ªët nh√© kh√¥ng l√† ·ª©ng √∫ng l·ªói t√πm lum ƒë√≥.

V·ªõi c·ªông ƒë·ªìng m√£ ngu·ªìn m·ªü ph√°t tri·ªÉn nh∆∞ v≈© b√£o ng√†y nay, v·ªõi m·ªôt ·ª©ng d·ª•ng c√≥ base t·ªët v√† m·ªôt plugin API t·ªëi th√¨ t·ªëc ƒë·ªô ph√°t tri·ªÉn s·∫Ω kh√¥ng th·ªÉ tin n·ªïi. VD nh∆∞ [slack](https://www.youtube.com/watch?v=B6zVzWU95Sw) m·ªôt h·ªá th·ªëng nh·∫Øn tin v√† trao ƒë·ªïi c√¥ng vi·ªác ƒëang r·∫•t n·ªïi tuy c≈©ng ch·ªâ m·ªõi ph√°t tri·ªÉn ƒë∆∞·ª£c v√†i nƒÉm nh∆∞ng s·ªë l∆∞·ª£ng plugin trong kho c·ªßa slack ƒë√£ r·∫•t kh·ªïng l·ªì h·∫ßu h·∫øt l√† do c√°c b√™n th·ª© ba ph·∫£t tri·ªÉn, th·ª±c s·ª± n√¢ng gi√° tr·ªã c·ªßa ·ª©ng d·ª•ng ban ƒë·∫ßu l√™n g·∫•p nhi·ªÅu l·∫ßn m√† m·ªôt team kh√¥ng th·ªÉ l√†m h·∫øt ƒë∆∞·ª£c.

## R·ªìi, th·∫ø c√†i ƒë·∫∑t th·∫±ng n√†y th·∫ø n√†o?

ƒê·ªëi v·ªõi c√°c script language nh∆∞ Javascript, PHP, python‚Ä¶ v·ªõi d·∫∑c ƒëi·ªÉm m·ªói l·∫ßn ch·∫°y l√† m·ªôt l·∫ßn **th√¥ng d·ªãch** th√¨ c√≥ v·∫ª kh√¥ng g·∫∑p tr·ªü ng·∫°i g√¨ ch·ªâ vi·ªác d√πng m·ªôt th·∫±ng callback l√† xong c√°i n√†y m√¨nh s·∫Ω n√≥i ƒë·∫øn v√†o m·ªôt ng√†y ƒë·∫πp tr·ªùi kh√¥ng xa. V·ªõi Java c√¢u chuy·ªán c√≥ v·∫ª kh√¥ng d·ªÖ d√†ng nh∆∞ th·∫ø, Java th√¨ kh√¥nng c√≥ callback hay c√°i g√¨ t∆∞·ª£ng t·ª± c·∫£, m√¨nh th√¨ g√† Java n√™n c≈©ng th·∫•y v·ª• n√†y h∆°i khoai m·ªôt ch√∫t.

![application-architecture](../media/application-architecture.jpg)

V·ªÅ c∆° b·∫£n ƒë·ªÉ c√≥ th·ªÉ c·∫Øm ƒë∆∞·ª£c plugin th√¨ ·ª©ng d·ª•ng ph·∫£i c√≥ ki·∫øn tr√∫c ƒë∆°n gi·∫£n nh·∫•t nh∆∞ trong h√¨nh tr√™n, hai th√†nh ph·∫ßn c∆° b·∫£n ƒë√≥ l√† **application core** v√† **plugin manager**:
- **application core:** th·∫±ng n√†y l√† ·ª©ng d·ª•ng ch·ªß c√≥ nhi·ªám b·ª• b√†o ƒë·∫£m logic c·ªßa h·ªá th·ªëng, th·ª±c hi·ªán c√°c t√°c v·ª• v√† hook (g·ªçi) c√°c plugin th·ª±c hi·ªán nhi·ªám v·ª• c·ªßa m√¨nh trong runtime.
- **plugins manager:** th·∫±ng ch·ªãu s·ª± ch·ªâ ƒë·∫°o c·ªßa th·∫±ng core c√≥ nhi·ªám v·ª• ƒëƒÉng k√Ω c√°c plugin th√™m, g·ª°, b·∫≠t, t·∫Øt c√°c plugin.

ƒê·ªÉ c√≥ th·ªÉ c·∫Øm ƒë∆∞·ª£c plugin ta ph·∫£i c√≥ m·ªôt plugin interface ƒë√¢y l√† giao di·ªán m√† t·∫•t c·∫£ c√°c plugin s·∫Ω k·∫ø th·ª´a, plugin manager s·∫ª load c√°c plugins v√† initial (n√¥m na l√† t·∫°o ra th·ª±c th·ªÉ c·ªßa m·ªói plugin) v√†o trong m·ªôt List c√°c plugins r·ªìi t·ª´ ƒë√≥ application core s·∫Ω l·∫ßn l∆∞·ªçt m√≥c ra t·ª´ c√°i m·ªôt v√† b·∫Øt n√≥ th·ª±c hi·ªán nhi·ªám v·ª• nh·∫•t ƒë·ªãnh.

H√¨, m√¨nh gi·∫£i th√≠ch c·ªß chu·ªëi qu√° ch·∫Øc ko ai hi·ªÉu n·ªïi nh·ªâ. ƒê·ªÉ tr·ª±c quan sinh ƒë·ªông m·ªùi ae xem v√≠ d·ª• b√™n d∆∞·ªõi.

## V√≠ d·ª• tr·ª±c quan n√®

·ªü v√≠ d·ª• n√†y m√¨nh s·∫Ω t·∫°o m·ªôt ·ª©ng d·ª•ng ƒë∆°n gi·∫©n v·ªõi ƒë·∫ßu v√†o l√† 1 s·ªë, c√°c plugin s·∫Ω ƒë∆∞·ªçc th√™m v√†o ƒë√™ ch·∫ø bi·∫øn s·ªë ƒë√≥ ƒë·ªÉ ƒë∆∞a ra k·∫øt qu·∫£ cu·ªëi c√πng c·ªông tr·ª´ nh√¢n chia g√¨ ƒë√≥.

Ok, ƒë·∫ßu ti√™n ch√∫ng ta ph·∫£i c√≥ m·ªôt th·∫±ng interface chung cho c√°c plugins. t·∫°m g·ªçi l√† **`PluginFunction.java`** ƒëi.

```
public interface PluginFunction {

	// let the application pass in a parameter
	public void setParameter (int param);

	// retrieve a result from the plugin
	public int getResult();

	// return the name of this plugin
	public String getPluginName();

	// can be called to determine whether the plugin
	// aborted execution due to an error condition
	public boolean hasError();
}
```

Ti·∫øp theo ta ph·∫£i c√≥ m·ªôt c√°i main ƒë·ªÉ ch·∫°y logic c·ªßa ·ª©ng d·ª•ng v√† g·ªçi c√°c plugin, ta g·ªçi l√† `PluginDemo.java` ch·ª©a h√†m main.
```
import java.io.File;
import java.util.*;

public class PluginDemo {
	//parameter for plugins
	int count;

	// the directory where we keep the plugin classes
	String pluginsDir;

	// a list where we keep an initialized object of each plugin class
	List plugins;

	public static void main (String args[]) {
		PluginDemo demo = new PluginDemo(args);
		demo.getPlugins();
		demo.runPlugins();
	}

	PluginDemo (String args[]) {
		if (args.length &gt; 0)
			count = Integer.parseInt(args[0]);
		else
			count = 1;

		if (args.length &gt; 1)
			pluginsDir = args[0];
		else
			pluginsDir = "plugins";

		plugins = new ArrayList();

		System.setSecurityManager(new PluginSecurityManager(pluginsDir));
	}

	protected void getPlugins() {
		File dir = new File(System.getProperty("user.dir") + File.separator + pluginsDir);
		ClassLoader cl = new PluginClassLoader(dir);
		if (dir.exists() &amp;&amp; dir.isDirectory()) {
			// we'll only load classes directly in this directory -
			// no subdirectories, and no classes in packages are recognized
			String[] files = dir.list();
			for (int i=0; i&lt;files.length; i++) {
				try {
					// only consider files ending in ".class"
					if (! files[i].endsWith(".class"))
						continue;

					Class c = cl.loadClass(files[i].substring(0, files[i].indexOf(".")));
					Class[] intf = c.getInterfaces();
					for (int j=0; j&lt;intf.length; j++) {
						if (intf[j].getName().equals("PluginFunction")) {
							// the following line assumes that PluginFunction has a no-argument constructor
							PluginFunction pf = (PluginFunction) c.newInstance();
							plugins.add(pf);
							continue;
						}
					}
				} catch (Exception ex) {
					System.err.println("File " + files[i] + " does not contain a valid PluginFunction class.");
				}
			}
		}
	}

	protected void runPlugins() {
		Iterator iter = plugins.iterator();
		while (iter.hasNext()) {
			PluginFunction pf = (PluginFunction) iter.next();
			try {
				pf.setParameter(count);
				System.out.print(pf.getPluginName());
				System.out.print(" ( "+count+" ) = ");
				if (pf.hasError()) {
					System.out.println("there was an error during plugin initialization");
					continue;
				}
				int result = pf.getResult();
				if (pf.hasError())
					System.out.println("there was an error during plugin execution");
				else
					System.out.println(result);
				count++;
			} catch (SecurityException secEx) {
				System.err.println("plugin '"+pf.getClass().getName()+"' tried to do something illegal");
			}
		}
	}
}
```
Ta th·∫•y trong h√†m `getPlugins` c√≥ m·ªôt v√≤ng for ƒë·ªÉ load h·∫øt c√°c class m√† c√≥ interface l√† `PluginFunction` r·ªìi t·∫°o ra m·ªôt th·ª±c th·ªÉ c·ªßa class ƒë√≥ v√† l∆∞u v√†o m·∫£ng `plugins`. Sau ƒë√≥ h√†m `runPlugins` s·∫Ω duy·ªát qua t·∫•t c·∫£ c·∫£c plugins set tham s·ªë ch·∫°y h√†m run c·ªßa t·ª´ng plugin v√† in ra k·∫øt qu·∫£.

Ngo√†i ra h√†m `getPlugins` c√≤n c√≥ m·ªôt ƒëi·ªÅu th√∫ v·ªã n·ªØa ch√≠nh l√† d√≤ng setSecurityManager, v√¨ ƒë√¢y l√† c√°c plugins ƒë·ªôc l·∫≠p v·ªõi h·ªá th·ªëng n√™n ta ph·∫£i x√©t qu·ªÅn h·∫°n cho n√≥ ch·ª© nh·ª° thanh ni√™n n√†o vui t√≠nh l·∫°i cho c√°i plugin x√≥a h·∫øt h·ªá ƒëi·ªÅu h√†nh th√¨ ch·ªâ bi·∫øt ng·ªìi ƒë·∫•y m√† kh√≥c th√¥i üò≠.

ƒê√¢y l√† n·ªôi dung file `PluginSecurityManager.java`
```
import java.io.File;

/**
* This is a fairly uptight security manager subclass. Classes loaded by
* the PluginClassLoader are highly restricted in what they are allowed to do.
* This is okay, because they're only supposed to calculate some values,
* for which all necessary data is already available to them.
*
* A SecurityManager consists of various methods that the system calls to
* check whether certain sensitive operations should be allowed. These
* methods can throw a SecurityException to prevent the operation from
* happening. With this SecurityManager, we want to prevent untrusted
* code that was loaded by a class loader from performing those sensitive operations.
* So we use inherited SecurityManager methods to check whether the call is being
* made by an untrusted class. If it is, we throw an exception.
* Otherwise, we simply return, allowing the operation to proceed normally.
*/

public class PluginSecurityManager extends SecurityManager {

	private String pluginDir = null;

	PluginSecurityManager (String dir) {
		pluginDir = dir;
	}

	/**
	 * This is the basic method that tests whether there is a class loaded
	 * by a ClassLoader anywhere on the stack. If so, it means that that
	 * untrusted code is trying to perform some kind of sensitive operation.
	 * We prevent it from performing that operation by throwing an exception.
	 * trusted() is called by most of the check...() methods below.
	 */
	protected void trusted() {
		if (inClassLoader()) throw new SecurityException();
	}

	/**
	 * These are all the specific checks that a security manager can
	 * perform. They all just call one of the methods above and throw a
	 * SecurityException if the operation is not allowed. This 
	 * SecurityManager subclass is perhaps a little too restrictive. For
	 * example, it doesn't allow loaded code to read *any* system properties,
	 * even though some of them are quite harmless.
	 */
	public void checkCreateClassLoader() { trusted(); }
	public void checkAccess (Thread g) { trusted(); }
	public void checkAccess (ThreadGroup g) { trusted(); }
	public void checkExit (int status) { throw new SecurityException("Not allowed."); }
	public void checkExec (String cmd) { trusted(); }
	public void checkLink (String lib) { trusted(); }
	public void checkRead (java.io.FileDescriptor fd) { trusted(); }
	public void checkRead (String file) {
//		String path = new File(file).getParentFile().getAbsolutePath();
//		if (! path.endsWith(pluginDir))
			trusted();
	}
	public void checkRead (String file, Object context) { trusted(); }
	public void checkWrite (java.io.FileDescriptor fd) { trusted(); }
	public void checkWrite (String file) { trusted(); }
	public void checkDelete (String file) { trusted(); }
	public void checkConnect (String host, int port) { trusted(); }
	public void checkConnect (String host,int port,Object context) {trusted();}
	public void checkListen (int port) { trusted(); }
	public void checkAccept (String host, int port) { trusted(); }
	public void checkMulticast (java.net.InetAddress maddr) { trusted(); }
	public void checkMulticast (java.net.InetAddress maddr, byte ttl) { trusted(); }
	public void checkPropertiesAccess() { trusted(); }
	public void checkPropertyAccess (String key) {
//		if (! key.equals("user.dir"))
			trusted();
	}
	public void checkPrintJobAccess() { trusted(); }
	public void checkSystemClipboardAccess() { trusted(); }
	public void checkAwtEventQueueAccess() { trusted(); }
	public void checkSetFactory() { trusted(); }
	public void checkMemberAccess (Class clazz, int which) { trusted(); }
	public void checkSecurityAccess (String provider) { trusted(); }

	/** Loaded code can only load classes from java.* packages */
	public void checkPackageAccess (String pkg) { 
		if (inClassLoader() &amp;&amp; !pkg.startsWith("java.") &amp;&amp; !pkg.startsWith("javax."))
			throw new SecurityException();
	}

	/** Loaded code can't define classes in java.* or sun.* packages */
	public void checkPackageDefinition (String pkg) { 
		if (inClassLoader() &amp;&amp; ((pkg.startsWith("java.") || pkg.startsWith("javax.") || pkg.startsWith("sun."))))
			throw new SecurityException();
	}

	/** 
	 * This is the one SecurityManager method that is different from the
	 * others. It indicates whether a top-level window should display an
	 * "untrusted" warning. The window is always allowed to be created, so
	 * this method is not normally meant to throw an exception. It should
	 * return true if the window does not need to display the warning, and
	 * false if it does. In this example, however, our text-based Service
	 * classes should never need to create windows, so we will actually
	 * throw an exception to prevent any windows from being opened.
	 **/
	public boolean checkTopLevelWindow (Object window) { 
		trusted();
		return true; 
	}
}
```

Ngo√†i ra ta c√≤n c·∫ßn 1 c√°i loader ƒë·ªÉ load c√°c plugins ra n·ªØa `PluginClassLoader.java`

```
import java.io.*;

  /**
   * In order to impose tight security restrictions on untrusted classes but
   * not on trusted system classes, we have to be able to distinguish between
   * those types of classes. This is done by keeping track of how the classes
   * are loaded into the system. By definition, any class that the interpreter
   * loads directly from the CLASSPATH is trusted. This means that we can't
   * load untrusted code in that way--we can't load it with Class.forName().
   * Instead, we create a ClassLoader subclass to load the untrusted code.
   * This one loads classes from a specified directory (which should not
   * be part of the CLASSPATH).
   */

public class PluginClassLoader extends ClassLoader {
    /** This is the directory from which the classes will be loaded */
    File directory;

    /** The constructor. Just initialize the directory */
    public PluginClassLoader (File dir) {
		directory = dir;
	}

    /** A convenience method that calls the 2-argument form of this method */
    public Class loadClass (String name) throws ClassNotFoundException { 
      return loadClass(name, true); 
    }

    /**
     * This is one abstract method of ClassLoader that all subclasses must
     * define. Its job is to load an array of bytes from somewhere and to
     * pass them to defineClass(). If the resolve argument is true, it must
     * also call resolveClass(), which will do things like verify the presence
     * of the superclass. Because of this second step, this method may be called to
     * load superclasses that are system classes, and it must take this into account.
     */
    public Class loadClass (String classname, boolean resolve) throws ClassNotFoundException {
      try {
        // Our ClassLoader superclass has a built-in cache of classes it has
        // already loaded. So, first check the cache.
        Class c = findLoadedClass(classname);

        // After this method loads a class, it will be called again to
        // load the superclasses. Since these may be system classes, we've
        // got to be able to load those too. So try to load the class as
        // a system class (i.e. from the CLASSPATH) and ignore any errors
        if (c == null) {
          try { c = findSystemClass(classname); }
          catch (Exception ex) {}
        }

        // If the class wasn't found by either of the above attempts, then
        // try to load it from a file in (or beneath) the directory
        // specified when this ClassLoader object was created. Form the
        // filename by replacing all dots in the class name with
        // (platform-independent) file separators and by adding the ".class" extension.
        if (c == null) {
          // Figure out the filename
          String filename = classname.replace('.',File.separatorChar)+".class";

          // Create a File object. Interpret the filename relative to the
          // directory specified for this ClassLoader.
          File f = new File(directory, filename);

          // Get the length of the class file, allocate an array of bytes for
          // it, and read it in all at once.
          int length = (int) f.length();
          byte[] classbytes = new byte[length];
          DataInputStream in = new DataInputStream(new FileInputStream(f));
          in.readFully(classbytes);
          in.close();

          // Now call an inherited method to convert those bytes into a Class
          c = defineClass(classname, classbytes, 0, length);
        }

        // If the resolve argument is true, call the inherited resolveClass method.
        if (resolve) resolveClass(c);

        // And we're done. Return the Class object we've loaded.
        return c;
      }
      // If anything goes wrong, throw a ClassNotFoundException error
      catch (Exception ex) { throw new ClassNotFoundException(ex.toString()); }
    }
}
```
Haiz, v·ªÅ c∆° b·∫£n h·ªá th·ªëng setup th·∫ø l√† xong, ti·∫øp theo ta s·∫Ω c·∫ßn 1 2 c√°i plugins ƒë·ªÉ test th·ªß xem n√≥ c√≥ ch·∫°y ·ªïn kh√¥ng, ta s·∫Ω ƒë·∫∑t c√°c file n√†y trong th∆∞ m·ª•c `plugins`.

t√¨nh b√¨nh ph∆∞ng c·ªßa tham s·ªë:
```
/**
 * This plugin squares its argument.
 */

public class Square implements PluginFunction {

	int parameter = 0;

	public void setParameter (int param) {
		parameter = param;
	}

	public int getResult() {
		return parameter * parameter;
	}

	public String getPluginName() {
		return "Square";
	}

	// yes, this operation can fail, but we are going to ignore this here
	public boolean hasError() {
		return false;
	}
```
c·ªông 1 ƒë∆°n v·ªã v√†o tham s·ªë:
```
/**
 * This plugin adds one to the parameter.
 */

public class PlusOne implements PluginFunction {

	int parameter = 0;

	public void setParameter (int param) {
		parameter = param;
	}

	public int getResult() {
		return parameter + 1;
	}

	public String getPluginName() {
		return "PlusOne";
	}

	// yes, ths operation can fail, but we are going to ignore this here
	public boolean hasError() {
		return false;
	}
}
```
`TryToExit.java` th·ª≠ cho thanh ni√™n n√†y l·∫°m qu·ªÅn t√Ω xem c√≥ ƒë∆∞·ª£c kh√¥ng, trong `PluginSecurityManager` ta ƒë√£ set kh√¥ng cho plugin tho√°t ch∆∞∆°ng tr√¨nh r·ªìi.

&nbsp;
```
/**
 * This plugin tries to call System.exit(), which the SecurityManager doesn't allow.
 */

public class TryToExit implements PluginFunction {

	public void setParameter (int param) {
		// this function doesn't care about its parameter,
		// so it doesn't even store it for later use
	}

	public int getResult() {
		// The next line will be caught by the SecurityManagers 'checkExit' method.
		System.exit(0);
		return 42;
	}

	public String getPluginName() {
		return "TryToExit";
	}

	// yes, this operation can fail, but we are going to ignore this here
	public boolean hasError() {
		return false;
	}
}
```

Ti·∫øp theo l√† d·ªãch v√† ch·∫°y th·ª≠, n·∫øu kh√¥ng c√≥ g√¨ sai th√¨ s·∫Ω thu ƒë∆∞·ª£c output nh∆∞ n√†y, m√¨nh d√πng java 8 n√™n c√≥ phun ra m·∫•y c√°i Note, th√¥i k·ªá d√π sao n√≥ v·∫´n ch·∫°y ƒë∆∞·ª£c üòÑ:
<pre class="theme:dark-terminal lang:sh decode:true ">minh@MINH-PC:~/Desktop/Plugin$ javac *.java
Note: PluginSecurityManager.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: PluginDemo.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
minh@MINH-PC:~/Desktop/Plugin$ java PluginDemo TryToExit ( 1 ) = plugin 'TryToExit' tried to do something illegal
PlusOne ( 1 ) = 2 
Square ( 2 ) = 4</pre>
Th·ª±c ra toppic n√†y c√≤n th√™m v·∫•n ƒë·ªÅ n·ªØa l√† build ra file jar v√† c√†i ƒë·∫∑t plugin b·∫±ng xml nh∆∞ng t·∫°p th·ªùi th·∫ø n√†y ƒë√£. Xin h·∫πn ae m·ªôt d·ªãp kh√°c.

Xin ch√¢n th√†nh c·∫£m ∆°n b·ªô code m·∫´u c·ªßa [Ulf Dittmer](http://www.javaranch.com/contact.jsp#UlfDittmer), c√°c b·∫°n code th·ªÉ [download](http://blogk.xyz/wp-content/uploads/2016/08/Plugin.zip) code d·ªÉ tham kh·∫£o.

Ph√πu‚Ä¶ c·∫£m ∆°n ae ƒë√£ theo d√µi ƒë·∫øn t·∫≠n ƒë√¢y, b√†i ƒë√£ d√†i tay quay ƒë√£ m·ªèi m√¨nh xin ph√©p d·ª´ng ph√≠m t·∫°i ƒë√¢y. Ch√∫c ae cu·ªëi tu·∫ßn vui v·∫ª.
xin ch√†o th√¢n √°i v√† qu·∫øt th·∫Øng.